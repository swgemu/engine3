/*
 *	engine/core/ManagedObject.cpp generated by engine3 IDL compiler 0.70
 */

#include "ManagedObject.h"

/*
 *	ManagedObjectStub
 */

enum {RPC_UPDATEFORWRITE__ = 3653780595,RPC_LOCK__BOOL_,RPC_LOCK__MANAGEDOBJECT_,RPC_RLOCK__BOOL_,RPC_RLOCK__MANAGEDOBJECT_,RPC_WLOCK__BOOL_,RPC_WLOCK__MANAGEDOBJECT_,RPC_UNLOCK__BOOL_,RPC_RUNLOCK__BOOL_,RPC_SETLOCKNAME__STRING_,RPC_NOTIFYDESTROY__,RPC_NOTIFYLOADFROMDATABASE__,RPC_INITIALIZETRANSIENTMEMBERS__,RPC_UPDATETODATABASE__,RPC_GETLASTCRCSAVE__,RPC_SETLASTCRCSAVE__INT_,RPC_GETLASTSAVETIME__,RPC_SETLASTSAVETIME__INT_,RPC_ISPERSISTENT__,RPC_GETPERSISTENCELEVEL__,};

ManagedObject::ManagedObject() {
	ManagedObjectImplementation* _implementation = new ManagedObjectImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("ManagedObject");
}

ManagedObject::ManagedObject(DummyConstructorParameter* param) {
	_setClassName("ManagedObject");
}

ManagedObject::~ManagedObject() {
}



void ManagedObject::__updateForWrite() {
	ManagedObjectImplementation* _implementation = static_cast<ManagedObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == nullptr)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEFORWRITE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateForWrite();
	}
}

void ManagedObject::__lock(bool doLock) {
	ManagedObjectImplementation* _implementation = static_cast<ManagedObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == nullptr)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_LOCK__BOOL_);
		method.addBooleanParameter(doLock);

		method.executeWithVoidReturn();
	} else {
		_implementation->lock(doLock);
	}
}

void ManagedObject::__lock(ManagedObject* obj) {
	ManagedObjectImplementation* _implementation = static_cast<ManagedObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == nullptr)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_LOCK__MANAGEDOBJECT_);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else {
		_implementation->lock(obj);
	}
}

void ManagedObject::__lock(Lockable* obj) {
	ManagedObjectImplementation* _implementation = static_cast<ManagedObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == nullptr)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->lock(obj);
	}
}

void ManagedObject::__rlock(bool doLock) {
	ManagedObjectImplementation* _implementation = static_cast<ManagedObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == nullptr)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RLOCK__BOOL_);
		method.addBooleanParameter(doLock);

		method.executeWithVoidReturn();
	} else {
		_implementation->rlock(doLock);
	}
}

void ManagedObject::__rlock(ManagedObject* obj) {
	ManagedObjectImplementation* _implementation = static_cast<ManagedObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == nullptr)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RLOCK__MANAGEDOBJECT_);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else {
		_implementation->rlock(obj);
	}
}

void ManagedObject::__rlock(Lockable* obj) {
	ManagedObjectImplementation* _implementation = static_cast<ManagedObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == nullptr)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->rlock(obj);
	}
}

void ManagedObject::__wlock(bool doLock) {
	ManagedObjectImplementation* _implementation = static_cast<ManagedObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == nullptr)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_WLOCK__BOOL_);
		method.addBooleanParameter(doLock);

		method.executeWithVoidReturn();
	} else {
		_implementation->wlock(doLock);
	}
}

void ManagedObject::__wlock(ManagedObject* obj) {
	ManagedObjectImplementation* _implementation = static_cast<ManagedObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == nullptr)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_WLOCK__MANAGEDOBJECT_);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else {
		_implementation->wlock(obj);
	}
}

void ManagedObject::__unlock(bool doLock) {
	ManagedObjectImplementation* _implementation = static_cast<ManagedObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == nullptr)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UNLOCK__BOOL_);
		method.addBooleanParameter(doLock);

		method.executeWithVoidReturn();
	} else {
		_implementation->unlock(doLock);
	}
}

void ManagedObject::__runlock(bool doLock) {
	ManagedObjectImplementation* _implementation = static_cast<ManagedObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == nullptr)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RUNLOCK__BOOL_);
		method.addBooleanParameter(doLock);

		method.executeWithVoidReturn();
	} else {
		_implementation->runlock(doLock);
	}
}

void ManagedObject::__setLockName(const String& name) {
	ManagedObjectImplementation* _implementation = static_cast<ManagedObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == nullptr)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLOCKNAME__STRING_);
		method.addAsciiParameter(name);

		method.executeWithVoidReturn();
	} else {
		_implementation->setLockName(name);
	}
}

bool ManagedObject::__notifyDestroy() {
	ManagedObjectImplementation* _implementation = static_cast<ManagedObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == nullptr)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYDESTROY__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->notifyDestroy();
	}
}

void ManagedObject::__writeObject(ObjectOutputStream* stream) {
	ManagedObjectImplementation* _implementation = static_cast<ManagedObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == nullptr)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->writeObject(stream);
	}
}

void ManagedObject::__writeJSON(JSONSerializationType& j) {
	ManagedObjectImplementation* _implementation = static_cast<ManagedObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == nullptr)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->writeJSON(j);
	}
}

void ManagedObject::readObject(ObjectInputStream* stream) {
	ManagedObjectImplementation* _implementation = static_cast<ManagedObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == nullptr)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->readObject(stream);
	}
}

bool ManagedObject::toBinaryStream(ObjectOutputStream* stream) {
	ManagedObjectImplementation* _implementation = static_cast<ManagedObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == nullptr)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->toBinaryStream(stream);
	}
}

bool ManagedObject::parseFromBinaryStream(ObjectInputStream* stream) {
	ManagedObjectImplementation* _implementation = static_cast<ManagedObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == nullptr)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->parseFromBinaryStream(stream);
	}
}

void ManagedObject::notifyLoadFromDatabase() {
	ManagedObjectImplementation* _implementation = static_cast<ManagedObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == nullptr)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYLOADFROMDATABASE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyLoadFromDatabase();
	}
}

DistributedObjectServant* ManagedObject::__getServant() {
	ManagedObjectImplementation* _implementation = static_cast<ManagedObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == nullptr)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getServant();
	}
}

void ManagedObject::initializeTransientMembers() {
	ManagedObjectImplementation* _implementation = static_cast<ManagedObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == nullptr)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZETRANSIENTMEMBERS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->initializeTransientMembers();
	}
}

void ManagedObject::updateToDatabase() {
	ManagedObjectImplementation* _implementation = static_cast<ManagedObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == nullptr)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATETODATABASE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateToDatabase();
	}
}

unsigned int ManagedObject::getLastCRCSave() const {
	ManagedObjectImplementation* _implementation = static_cast<ManagedObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == nullptr)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLASTCRCSAVE__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getLastCRCSave();
	}
}

void ManagedObject::setLastCRCSave(unsigned int crc) {
	ManagedObjectImplementation* _implementation = static_cast<ManagedObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == nullptr)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLASTCRCSAVE__INT_);
		method.addUnsignedIntParameter(crc);

		method.executeWithVoidReturn();
	} else {
		_implementation->setLastCRCSave(crc);
	}
}

unsigned int ManagedObject::getLastSaveTime() const {
	ManagedObjectImplementation* _implementation = static_cast<ManagedObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == nullptr)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLASTSAVETIME__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getLastSaveTime();
	}
}

void ManagedObject::setLastSaveTime(unsigned int timeval) {
	ManagedObjectImplementation* _implementation = static_cast<ManagedObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == nullptr)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLASTSAVETIME__INT_);
		method.addUnsignedIntParameter(timeval);

		method.executeWithVoidReturn();
	} else {
		_implementation->setLastSaveTime(timeval);
	}
}

bool ManagedObject::isPersistent() const {
	ManagedObjectImplementation* _implementation = static_cast<ManagedObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == nullptr)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPERSISTENT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isPersistent();
	}
}

int ManagedObject::getPersistenceLevel() const {
	ManagedObjectImplementation* _implementation = static_cast<ManagedObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == nullptr)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPERSISTENCELEVEL__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getPersistenceLevel();
	}
}

void ManagedObject::setPersistent(int level) {
	ManagedObjectImplementation* _implementation = static_cast<ManagedObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == nullptr)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->setPersistent(level);
	}
}

DistributedObjectServant* ManagedObject::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* ManagedObject::_getImplementationForRead() const {
	return _impl;
}

void ManagedObject::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	ManagedObjectImplementation
 */

ManagedObjectImplementation::ManagedObjectImplementation(DummyConstructorParameter* param) {
	_initializeImplementation();
}

ManagedObjectImplementation::~ManagedObjectImplementation() {
}


void ManagedObjectImplementation::finalize() {
}

void ManagedObjectImplementation::_initializeImplementation() {
	_setClassHelper(ManagedObjectHelper::instance());

	_this = nullptr;

	_serializationHelperMethod();
}

void ManagedObjectImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<ManagedObject*>(stub);
	DistributedObjectServant::_setStub(stub);
}

DistributedObjectStub* ManagedObjectImplementation::_getStub() {
	return _this.get();
}

ManagedObjectImplementation::operator const ManagedObject*() {
	return _this.get();
}

void ManagedObjectImplementation::_serializationHelperMethod() {
	_setClassName("ManagedObject");

}

void ManagedObjectImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(ManagedObjectImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool ManagedObjectImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (nameHashCode == 0x76457cca) {//_className 
		TypeInfo<String>::parseFromBinaryStream(&_className, stream);
		return true;
	}

	switch(nameHashCode) {
	case 0x62b0f0cf: //ManagedObject.persistenceLevel
		TypeInfo<int >::parseFromBinaryStream(&persistenceLevel, stream);
		return true;

	}

	return false;
}

void ManagedObjectImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = ManagedObjectImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int ManagedObjectImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = 0;
	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0x62b0f0cf; //ManagedObject.persistenceLevel
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&persistenceLevel, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;


	_nameHashCode = 0x76457cca;//_className
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String>::toBinaryStream(&_className, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	return _count + 1;
}

void ManagedObjectImplementation::writeJSON(nlohmann::json& j) {
	nlohmann::json thisObject = nlohmann::json::object();
	thisObject["persistenceLevel"] = persistenceLevel;

	j["ManagedObject"] = thisObject;
	j["_className"] = _className;
}

ManagedObjectImplementation::ManagedObjectImplementation() {
	_initializeImplementation();
	// engine/core/ManagedObject.idl():  		persistenceLevel = 0;
	persistenceLevel = 0;
	// engine/core/ManagedObject.idl():  		lastCRCSave = 0;
	lastCRCSave = 0;
	// engine/core/ManagedObject.idl():  		lastSaveTime = 0;
	lastSaveTime = 0;
}

bool ManagedObjectImplementation::toBinaryStream(ObjectOutputStream* stream) {
	// engine/core/ManagedObject.idl():  		writeObject(stream);
	writeObject(stream);
	// engine/core/ManagedObject.idl():  		return true;
	return true;
}

bool ManagedObjectImplementation::parseFromBinaryStream(ObjectInputStream* stream) {
	// engine/core/ManagedObject.idl():  		readObject(stream);
	readObject(stream);
	// engine/core/ManagedObject.idl():  		return true;
	return true;
}

void ManagedObjectImplementation::notifyLoadFromDatabase() {
}

unsigned int ManagedObjectImplementation::getLastCRCSave() const{
	// engine/core/ManagedObject.idl():  		return lastCRCSave;
	return lastCRCSave;
}

void ManagedObjectImplementation::setLastCRCSave(unsigned int crc) {
	// engine/core/ManagedObject.idl():  		lastCRCSave = crc;
	lastCRCSave = crc;
}

unsigned int ManagedObjectImplementation::getLastSaveTime() const{
	// engine/core/ManagedObject.idl():  		return lastSaveTime;
	return lastSaveTime;
}

void ManagedObjectImplementation::setLastSaveTime(unsigned int timeval) {
	// engine/core/ManagedObject.idl():  		lastSaveTime = timeval;
	lastSaveTime = timeval;
}

bool ManagedObjectImplementation::isPersistent() const{
	// engine/core/ManagedObject.idl():  		return persistenceLevel != 0;
	return persistenceLevel != 0;
}

int ManagedObjectImplementation::getPersistenceLevel() const{
	// engine/core/ManagedObject.idl():  		return persistenceLevel;
	return persistenceLevel;
}

void ManagedObjectImplementation::_setClassName(const String& name) {
	// engine/core/ManagedObject.idl():  		_className = name;
	_className = name;
}

/*
 *	ManagedObjectAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


ManagedObjectAdapter::ManagedObjectAdapter(ManagedObject* obj) : DistributedObjectAdapter(static_cast<DistributedObjectStub*>(obj)) {
}

void ManagedObjectAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_UPDATEFORWRITE__:
		{
			
			updateForWrite();
			
		}
		break;
	case RPC_LOCK__BOOL_:
		{
			bool doLock = inv->getBooleanParameter();
			
			lock(doLock);
			
		}
		break;
	case RPC_LOCK__MANAGEDOBJECT_:
		{
			ManagedObject* obj = static_cast<ManagedObject*>(inv->getObjectParameter());
			
			lock(obj);
			
		}
		break;
	case RPC_RLOCK__BOOL_:
		{
			bool doLock = inv->getBooleanParameter();
			
			rlock(doLock);
			
		}
		break;
	case RPC_RLOCK__MANAGEDOBJECT_:
		{
			ManagedObject* obj = static_cast<ManagedObject*>(inv->getObjectParameter());
			
			rlock(obj);
			
		}
		break;
	case RPC_WLOCK__BOOL_:
		{
			bool doLock = inv->getBooleanParameter();
			
			wlock(doLock);
			
		}
		break;
	case RPC_WLOCK__MANAGEDOBJECT_:
		{
			ManagedObject* obj = static_cast<ManagedObject*>(inv->getObjectParameter());
			
			wlock(obj);
			
		}
		break;
	case RPC_UNLOCK__BOOL_:
		{
			bool doLock = inv->getBooleanParameter();
			
			unlock(doLock);
			
		}
		break;
	case RPC_RUNLOCK__BOOL_:
		{
			bool doLock = inv->getBooleanParameter();
			
			runlock(doLock);
			
		}
		break;
	case RPC_SETLOCKNAME__STRING_:
		{
			 String name; inv->getAsciiParameter(name);
			
			setLockName(name);
			
		}
		break;
	case RPC_NOTIFYDESTROY__:
		{
			
			bool _m_res = notifyDestroy();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_NOTIFYLOADFROMDATABASE__:
		{
			
			notifyLoadFromDatabase();
			
		}
		break;
	case RPC_INITIALIZETRANSIENTMEMBERS__:
		{
			
			initializeTransientMembers();
			
		}
		break;
	case RPC_UPDATETODATABASE__:
		{
			
			updateToDatabase();
			
		}
		break;
	case RPC_GETLASTCRCSAVE__:
		{
			
			unsigned int _m_res = getLastCRCSave();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_SETLASTCRCSAVE__INT_:
		{
			unsigned int crc = inv->getUnsignedIntParameter();
			
			setLastCRCSave(crc);
			
		}
		break;
	case RPC_GETLASTSAVETIME__:
		{
			
			unsigned int _m_res = getLastSaveTime();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_SETLASTSAVETIME__INT_:
		{
			unsigned int timeval = inv->getUnsignedIntParameter();
			
			setLastSaveTime(timeval);
			
		}
		break;
	case RPC_ISPERSISTENT__:
		{
			
			bool _m_res = isPersistent();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETPERSISTENCELEVEL__:
		{
			
			int _m_res = getPersistenceLevel();
			resp->insertSignedInt(_m_res);
		}
		break;
	default:
		throw Exception("Method does not exists");
	}
}

void ManagedObjectAdapter::updateForWrite() {
	(static_cast<ManagedObject*>(stub))->updateForWrite();
}

void ManagedObjectAdapter::lock(bool doLock) {
	(static_cast<ManagedObject*>(stub))->lock(doLock);
}

void ManagedObjectAdapter::lock(ManagedObject* obj) {
	(static_cast<ManagedObject*>(stub))->lock(obj);
}

void ManagedObjectAdapter::rlock(bool doLock) {
	(static_cast<ManagedObject*>(stub))->rlock(doLock);
}

void ManagedObjectAdapter::rlock(ManagedObject* obj) {
	(static_cast<ManagedObject*>(stub))->rlock(obj);
}

void ManagedObjectAdapter::wlock(bool doLock) {
	(static_cast<ManagedObject*>(stub))->wlock(doLock);
}

void ManagedObjectAdapter::wlock(ManagedObject* obj) {
	(static_cast<ManagedObject*>(stub))->wlock(obj);
}

void ManagedObjectAdapter::unlock(bool doLock) {
	(static_cast<ManagedObject*>(stub))->unlock(doLock);
}

void ManagedObjectAdapter::runlock(bool doLock) {
	(static_cast<ManagedObject*>(stub))->runlock(doLock);
}

void ManagedObjectAdapter::setLockName(const String& name) {
	(static_cast<ManagedObject*>(stub))->setLockName(name);
}

bool ManagedObjectAdapter::notifyDestroy() {
	return (static_cast<ManagedObject*>(stub))->notifyDestroy();
}

void ManagedObjectAdapter::notifyLoadFromDatabase() {
	(static_cast<ManagedObject*>(stub))->notifyLoadFromDatabase();
}

void ManagedObjectAdapter::initializeTransientMembers() {
	(static_cast<ManagedObject*>(stub))->initializeTransientMembers();
}

void ManagedObjectAdapter::updateToDatabase() {
	(static_cast<ManagedObject*>(stub))->updateToDatabase();
}

unsigned int ManagedObjectAdapter::getLastCRCSave() const {
	return (static_cast<ManagedObject*>(stub))->getLastCRCSave();
}

void ManagedObjectAdapter::setLastCRCSave(unsigned int crc) {
	(static_cast<ManagedObject*>(stub))->setLastCRCSave(crc);
}

unsigned int ManagedObjectAdapter::getLastSaveTime() const {
	return (static_cast<ManagedObject*>(stub))->getLastSaveTime();
}

void ManagedObjectAdapter::setLastSaveTime(unsigned int timeval) {
	(static_cast<ManagedObject*>(stub))->setLastSaveTime(timeval);
}

bool ManagedObjectAdapter::isPersistent() const {
	return (static_cast<ManagedObject*>(stub))->isPersistent();
}

int ManagedObjectAdapter::getPersistenceLevel() const {
	return (static_cast<ManagedObject*>(stub))->getPersistenceLevel();
}

/*
 *	ManagedObjectHelper
 */

ManagedObjectHelper* ManagedObjectHelper::staticInitializer = ManagedObjectHelper::instance();

ManagedObjectHelper::ManagedObjectHelper() {
	className = "ManagedObject";

	Core::getObjectBroker()->registerClass(className, this);
}

void ManagedObjectHelper::finalizeHelper() {
	ManagedObjectHelper::finalize();
}

DistributedObject* ManagedObjectHelper::instantiateObject() {
	return new ManagedObject(DummyConstructorParameter::instance());
}

DistributedObjectServant* ManagedObjectHelper::instantiateServant() {
	return new ManagedObjectImplementation();
}

DistributedObjectPOD* ManagedObjectHelper::instantiatePOD() {
	return new ManagedObjectPOD();
}

DistributedObjectAdapter* ManagedObjectHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new ManagedObjectAdapter(static_cast<ManagedObject*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

/*
 *	ManagedObjectPOD
 */

ManagedObjectPOD::~ManagedObjectPOD() {
}

ManagedObjectPOD::ManagedObjectPOD(void) {
	_className = "ManagedObject";
}


void ManagedObjectPOD::writeJSON(nlohmann::json& j) {
	nlohmann::json thisObject = nlohmann::json::object();
	if (persistenceLevel)
		thisObject["persistenceLevel"] = persistenceLevel.value();

	j["ManagedObject"] = thisObject;
	j["_className"] = _className;
}


void ManagedObjectPOD::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = ManagedObjectPOD::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int ManagedObjectPOD::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = 0;
	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	if (persistenceLevel) {
	_nameHashCode = 0x62b0f0cf; //ManagedObject.persistenceLevel
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&persistenceLevel.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}


	_nameHashCode = 0x76457cca;//_className
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String>::toBinaryStream(&_className, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	return _count + 1;
}

bool ManagedObjectPOD::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (nameHashCode == 0x76457cca) {//_className 
		TypeInfo<String>::parseFromBinaryStream(&_className, stream);
		return true;
	}

	switch(nameHashCode) {
	case 0x62b0f0cf: //ManagedObject.persistenceLevel
		{
			int _mnpersistenceLevel;
			TypeInfo<int >::parseFromBinaryStream(&_mnpersistenceLevel, stream);
			persistenceLevel = std::move(_mnpersistenceLevel);
		}
		return true;

	}

	return false;
}

void ManagedObjectPOD::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(ManagedObjectPOD::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

}

void ManagedObjectPOD::writeObjectCompact(ObjectOutputStream* stream) {
	TypeInfo<int >::toBinaryStream(&persistenceLevel.value(), stream);


}

